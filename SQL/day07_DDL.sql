--DDL:CREATE, ALTER, DROP, TRUNCATE, RENAME
#테이블 생성 - 제약조건
--<1>컬럼 수준에서 제약하는 경우
--<2>테이블 수준에서 제약하는 경우

[1]PRIMARY KEY
--UNIQUE한 값 + NOT NULL
    <1>컬럼수준
--    컬럼명 CONSTRAINT 제약조건명 제약조건유형...
    CREATE TABLE TEST_TAB1(
        ID NUMBER(2) CONSTRAINT TEST_TAB1_ID_PK PRIMARY KEY,
        NAME VARCHAR2(20),
        TEL CHAR(15)
    );
    
    DESC TEST_TAB1;
    INSERT INTO TEST_TAB1 VALUES(1,'홍길동', NULL);
    SELECT * FROM TEST_TAB1;
    
    -- 데이터 사전(DATE DICTIONARY)에서 확인
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='TEST_TAB1';

    <2>테이블 수준에서 제약
--    컬럼명 CONSTRAINT 제약조건명 제약조건유형 (컬럼명)...
    CREATE TABLE TEST_TAB2(
        ID NUMBER(2),
        NAME VARCHAR2(20),
        TEL CHAR(15),
        --컬럼 나열 후 제약조건 기술
        CONSTRAINT TEST_TAB2_ID_PK PRIMARY KEY(ID)
    );
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME='TEST_TAB2';   
    
--컬럼 수준
CREATE TABLE TEST_TAB3(--제약조건을 안줘도 됨_시스템이 알아서 이름 붙임
    ID NUMBER(2) PRIMARY KEY,
    NAME VARCHAR2(20)
);
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME='TEST_TAB3';
--테이블 수준
CREATE TABLE TEST_TAB4(
    ID NUMBER(2),
    NAME VARCHAR2(20),
    PRIMARY KEY(ID)
);
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME='TEST_TAB4';

[2]FOREIGN KEY - references
--부모테이블이 먼저 나옴
--MASTER TABLE(부모테이블)
CREATE TABLE DEPT_TAB(
    DEPTNO NUMBER(2),
    DEPT CHAR(20),
    LOC CHAR(15),
    CONSTRAINT DEPT_TAB_DEPTNO_PK PRIMARY KEY(DEPTNO)--테이블 수준의 제약조건
);
--DETAIL TABLE(자식테이블)
CREATE TABLE EMP_TAB(
    EMPNO NUMBER(4) CONSTRAINT EMP_TAB_EMPNO_PK PRIMARY KEY,--컬럼 수준의 제약조건
    ENAME VARCHAR2(20),
    JOB VARCHAR2(10),
    MGR NUMBER(4) CONSTRAINT EMP_TAB_MGR_FK REFERENCES EMP_TAB(EMPNO),--컬럼수준의 FOREIGN KEY제약
    HIREDATE DATE,
    SAL NUMBER(7,2),--7자리 중 소수 2자리
    COMM NUMBER(7,2),
    DEPTNO NUMBER(2),
    --테이블 수준의 제약(FK)
    CONSTRAINT EMP_TAB_DEPTNO_FK FOREIGN KEY(DEPTNO) REFERENCES DEPT_TAB(DEPTNO)
);
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='EMP_TAB';



#ON DELETE CASECADE 옵션
--테스트용 게시판 부모 테이블
CREATE TABLE BOARD(
    NUM NUMBER(4) PRIMARY KEY,
    TITLE VARCHAR2(100) NOT NULL,
    CONTENT VARCHAR2(1000),
    WDATE DATE DEFAULT SYSDATE);
--자식테이블
CREATE TABLE REPLY(
    RNUM NUMBER(4) PRIMARY KEY,
    RCONTENT VARCHAR2(1000),
    RWDATE DATE DEFAULT SYSDATE,
    NUM_FK NUMBER(4) REFERENCES BOARD(NUM) ON DELETE CASCADE
    --FK제약조건은 부모테이블을 참조하기때문에 부모테이블이 반드시 기술되어있어야한다.
);

--ON DELETE CASCADE옵션을 주면 자식 레코드가 있어도
--부모의 레코드를 삭제할 수 있다. 이때 자식 레코드도 같이 삭제된다.

INSERT INTO BOARD(NUM, TITLE, CONTENT)
VALUES(1,'첫글','HI');
INSERT INTO BOARD(NUM, TITLE, CONTENT)
VALUES(2,'SECOND','HELLO');

COMMIT;
SELECT * FROM BOARD;

--문1]1번 글에 대한 댓글 2개
INSERT INTO REPLY(RNUM, RCONTENT, NUM_FK)
VALUES(1,'1ST',1);
INSERT INTO REPLY(RNUM, RCONTENT, NUM_FK)
VALUES(2,'1ST2',1);
--문2]2번 글에 대한 댓글 1개
INSERT INTO REPLY(RNUM, RCONTENT, NUM_FK)
VALUES(3,'2ND',2);

SELECT * FROM REPLY;

--문3]BOARD와 REPLY JOIN해서 보기
SELECT B.*, R.*
FROM BOARD B LEFT OUTER JOIN REPLY R
ON B.NUM = R.NUM_FK;

--BOARD 테이블에서 1번 게시글을 삭제하세요
DELETE FROM BOARD WHERE NUM=1;

[3]UNIQUE KEY - PRIMARY KEY와 다르게 NULL값 사용 가능
<1> 컬럼수준 제약

CREATE TABLE UNI_TAB1(
    NO NUMBER(2) PRIMARY KEY,
    NAME VARCHAR2(20) NOT NULL,
    USERID VARCHAR2(16) CONSTRAINT UNI_TAB1_USERID_UK UNIQUE,
    TEL CHAR(15)
);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME='UNI_TAB1';

INSERT INTO UNI_TAB1
VALUES(1,'SHU','KILLER',NULL);
INSERT INTO UNI_TAB1
VALUES(2,'SALLA','HEALTHY',NULL);
INSERT INTO UNI_TAB1
VALUES(3,'HOLYC',NULL,NULL);

COMMIT;

<2>테이블 수준의 제약
CREATE TABLE UNI_TAB2(
    NO NUMBER(4) PRIMARY KEY,
    NAME VARCHAR2(20) NOT NULL,
    USERID VARCHAR2(16),
    TEL CHAR(15),
    CONSTRAINT UNI_TAB2_USERID_UK UNIQUE(USERID)
);

[4] NOT NULL - 테이블 수준의 제약 불가능(컬럼수준만 가능)
create table nn_tab(
    deptno number(2) primary key, --unique + not null
    dname varchar2(20) constraint nn_tab_dname_nn not null,
    loc varchar2(30) not null--제약조건 이름 없이도 가능(system이 알아서 지정해줌)    
);
--데이터사전에서 조회
select * from user_constraints where table_name='NN_TAB';
--데이터 삽입
INSERT INTO NN_TAB VALUES(10,'ACCOUNTING','NEWYORK');
COMMIT;
SELECT * FROM NN_TAB;

[5] CHECK
<1>컬럼 수준의 제약
CREATE TABLE CK_TAB1(
    DEPTNO NUMBER(2) CONSTRAINT CK_TAB1_DEPTNO_CK CHECK(DEPTNO>0 AND DEPTNO<21),
    DNAME CHAR(20),
    LOC CHAR(20)
);
--데이터사전에서 조회
select * from user_constraints where table_name='CK_TAB1';
--데이터 삽입
INSERT INTO CK_TAB1 VALUES(20,'ACCOUNTIN','LA');--DEPTNO 1~20 외의 숫자는 제약조건위반
COMMIT;
SELECT * FROM CK_TAB1;

<2>테이블 수준의 제약
--DEPTNO값은 10,20,30,40 값만 갖도록 CHECK제약조건을 테이블 수준에서 주세요
CREATE TABLE CK_TAB2(
    DEPTNO NUMBER(2),
    DNAME CHAR(20),
    LOC CHAR(20),
    CONSTRAINT CK_TAB2_DEPTNO_CK CHECK(DEPTNO IN (10,20,30,40))
);
INSERT INTO CK_TAB2 VALUES(10,'SALES','SEOUL');
SELECT * FROM CK_TAB2;
-----------------------------------------------------------------
ALTER 문-이미 생성된 테이블 변경할 때 사용
[1] 제약조건 추가
ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 제약조건유형(컬럼명);

CREATE TABLE USER_TAB(
    ID NUMBER(4),
    NAME VARCHAR2(20),
    TEL CHAR(15)
);
DESC USER_TAB;
--데이터사전에서 확인
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='USER_TAB';
--USER_TAB에 ID컬럼에 PRIMARY KEY제약조건을 추가
ALTER TABLE USER_TAB ADD CONSTRAINT USER_TAB_ID_PK PRIMARY KEY(ID);

[2]제약조건 이름 변경
ALTER TABLE 테이블명 RENAME CONSTRAINT 기존제약조건명 TO 새제약조건명;

--USER_TAB_ID_PK이름을 USER_TAB_PK로 변경
ALTER TABLE USER_TAB RENAME CONSTRAINT USER_TAB_ID_PK TO USER_TAB_PK;
--데이터사전에서 확인
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='USER_TAB';

[3]제약조건 삭제
ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명;

--USER_TAB에 PRIMARY KEY제약조건을 삭제
ALTER TABLE USER_TAB DROP CONSTRAINT USER_TAB_PK;
--데이터사전에서 확인
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='USER_TAB';

[3]컬럼 추가/변경/삭제
-- ALTER TABLE 테이블명 ADD 추가할 컬럼 정보 [default expr]
-- ALTER TABLE 테이블명 MODIFY 변경할 컬럼 정보 [default expr]
-- ALTER TABLE 테이블명 DROP column 삭제할 컬럼명
-- ALTER TABLE 테이블명 RENAME COLUMN OLD컬럼명 TO NEW컬럼명

CREATE TABLE BOARD_TAB(
    NO NUMBER
);

DESC BOARD_TAB;

--문1]BOARD_TAB에 TITLE VARCHAR2(100) NOT NULL컬럼을 추가하세요
ALTER TABLE BOARD_TAB ADD TITLE VARCHAR2(100) NOT NULL;
--문2]BOARD_TAB에 NAME VARCHAR2(20)컬럼을 추가하세요
ALTER TABLE BOARD_TAB ADD NAME VARCHAR2(20);
--문3]BOARD_TAB에 NO컬렴명을 NUM으로 수정
ALTER TABLE BOARD_TAB RENAME COLUMN NO TO NUM;
--문4]NUM의 컬럼 자료형을 CHAR(10)으로 수정
ALTER TABLE BOARD_TAB MODIFY NUM CHAR(10);
--문5]NAME컬럼을 삭제하세요
ALTER TABLE BOARD_TAB DROP COLUMN NAME;
DESC BOARD_TAB;

[4]객체이름 변경=>(테이블도 객체다)
--RENAME OLD_NAME TO NEW_NAME

--문1]BOARD_TAB 테이블 이름을 BBS_TAB으로 변경
RENAME BOARD_TAB TO BBS_TAB;
DESC BBS_TAB;
SELECT * FROM TAB;--SCOTT이 가진 모든 테이블 조회
SELECT * FROM USER_OBJECTS;--유저가 가진 모든 객체 조회

#테이블 삭제 - ROLLBACK 안됨
--DROP TABLE 테이블명 CASCADE CONSTRAINT--제약조건도 같이 삭제
--문1]BBS_TAB을 삭제
DROP TABLE BBS_TAB CASCADE CONSTRAINT;
--DROP TABLE 테이블명 PURGE;--찌꺼기까지 완전히 삭제(=휴지통 비우기)

# 테이블 구조는 남기도 데이터만 삭제 - DELETE와 유사하지만 DELETE보다 효율 좋음
--TRUNCATE TABLE 테이블명;
SELECT * FROM EMP2;
TRUNCATE TABLE EMP2;--ROLLBACK이 안됨(DDL문 전체 공통)

---------------------------------PDF실습----------------------------------
--MASTER TABLE-부모
CREATE TABLE ZIPCODE(
    post1 CHAR(3),
    post2 CHAR(3), 
    ADDR VARCHAR2(60) CONSTRAINT ZIPCODE_ADDR_NN NOT NULL,
    CONSTRAINT ZIPCODE_POST_PK PRIMARY KEY (POST1, POST2)
);
--DETAIL TABLE-자식
CREATE TABLE MEMBER_TAB(
    ID NUMBER(4,0) CONSTRAINT MEMBER_TAB_ID_PK PRIMARY KEY,
    NAME VARCHAR2(10), 
    GENDER CHAR(1) 
    CONSTRAINT MEMBER_TAB_GENDER_CK CHECK(GENDER IN ('F', 'M')),
    JUMIN1 CHAR(6),
    JUMIN2 CHAR(7),
    TEL VARCHAR2(15),
    POST1 CHAR(3),
    POST2 CHAR(3),
    ADDR VARCHAR2(60),
    CONSTRAINT MEMBER_TAB_JUMIN_UK UNIQUE(JUMIN1, JUMIN2),
    CONSTRAINT MEMBER_TAB_POST_FK FOREIGN KEY (POST1, POST2) REFERENCES ZIPCODE (POST1, POST2)
);